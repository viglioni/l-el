#+title: CHANGELOG

All notable changes to this project will be documented in this file.

* Unreleased

** Added
- =l-version= function to return the current version of l.el
- Release script now automatically updates =l-version= function during version bumps
- =l-generic-remove-method= function to remove specific implementations from generic functions
  - Removes only the method matching the given pattern, leaving other implementations intact
  - Automatically regenerates dispatch function after removal
  - Example: =(l-generic-remove-method 'lempty '((x :string)))= removes only the string implementation
- New simplified syntax for struct/class types in =ldef= patterns:
  - =(param struct-name)= instead of =(param :instance_of struct-name)=
  - =(param (list struct-name))= instead of =(param :list_of_instances struct-name)=
  - Example: =(ldef process-point (p point) -> ...)= matches =point= struct instances
  - Example: =(ldef process-points (pts (list point)) -> ...)= matches lists of =point= instances
  - Fully backward compatible - old =:instance_of= and =:list_of_instances= syntax still works
- Enhanced =:list_of= to work with both keyword types and struct/class types:
  - =(param :list_of :integer)= - list of integers (keyword type)
  - =(param :list_of point)= - list of =point= instances (struct type)
  - Note: =(param :list_of point)= is equivalent to =(param (list point))=
- Typed =:rest= parameters for type-checked variadic arguments:
  - =(param :rest :keyword)= - rest parameter that only accepts arguments matching a keyword type
  - =(param :rest struct-name)= - rest parameter that only accepts instances of a struct/class type
  - Examples:
    - =(ldef sum (nums :rest :integer) -> (apply '+ nums))= - only accepts integers
    - =(ldef process-points (pts :rest point) -> ...)= - only accepts =point= struct instances
  - Typed rest has higher specificity than untyped rest, enabling fallback patterns
  - Untyped =(param :rest)= continues to work as before, accepting any arguments
  - Type checking uses same predicates as =:list_of= for consistency

** Changed
- Updated =l-mode= syntax highlighting colors:
  - =ldef= function names now use =font-lock-function-name-face= (purple) instead of =font-lock-keyword-face=
  - Arrow (=->=) now uses =font-lock-constant-face= (same color as =@doc=) for better visual consistency
- Updated =l-generic-cleanup= documentation to reference =l-generic-remove-method= for removing specific implementations
- Pattern matching now distinguishes between symbol types (structs/classes) and value matches
  - Symbol types like =point=, =foo-struct= are matched via =cl-typep=
  - Special values =t= and =nil= remain as value matches
  - Keywords like =:integer=, =:string= remain as type predicates

* 1.0.0 - 2025-11-27

** Breaking Changes
- =ldef= now requires arrow (=->=) syntax to separate arguments from body
  - Old syntax: =(ldef add (x y) (+ x y))=
  - New syntax: =(ldef add x y -> (+ x y))=
  - This aligns =ldef= with the =l= lambda macro syntax for consistency
  - Arguments before =->= are parameter patterns
- =ldef= value matching syntax simplified to direct literal matching
  - Old syntax: =(ldef fib (n 0) -> 0)= - wrapped pattern
  - New syntax: =(ldef fib 0 -> 0)= - direct value
  - Lists in patterns =(param ...)= now ALWAYS indicate type matching or rest parameters
  - To match literal values: use direct syntax for numbers, strings, keywords, quoted symbols, =nil=, =t=, vectors, and quoted lists
  - Examples:
    - Numbers: =(ldef fib 0 -> 0)= =(ldef fib 1 -> 1)=
    - Strings: =(ldef greet "Alice" -> ...)=
    - Keywords: =(ldef handle :success -> ...)=
    - Quoted symbols: =(ldef parse 'foo -> ...)=
    - Booleans: =(ldef check nil -> ...)= =(ldef check t -> ...)=
    - Vectors: =(ldef process [] -> ...)= =(ldef process [1 2 3] -> ...)=
    - Lists: =(ldef handle '(1 2 3) -> ...)= =(ldef handle '() -> ...)=

** Changed
- Redesigned type specificity system to use lexicographic ordering instead of point-based scoring
  - Prevents multiple category types from outscoring single primitive types
  - Ensures primitive types (=:list=, =:integer=, =:string=) always match before category types (=:sequence=, =:array=, =:number=)
  - Specificity now uses string concatenation: value ("d") > parameterized ("c") > primitive ("b") > category ("a") > wildcard ("0")
  - Example: ="b"= (one primitive) > ="aaa"= (three categories)
- Added =l-instanceof= utility function for checking if an element matches a type (keyword or struct/class)
- Categorized types into =l-generic-primitive-types= and =l-generic-category-types= for proper specificity handling
- Enhanced =l-raise= to support =invalid-rest-parameter= error type
- Improved =&rest= validation in =ldef= to detect misuse in nested argument patterns
- Enhanced =l-mode= syntax highlighting:
  - =ldef= function names now highlighted with =font-lock-keyword-face= (bold purple/magenta) in definitions
  - =ldef= function *calls* also highlighted to distinguish them from regular functions
  - Arrow (=->=) in =ldef= definitions highlighted with same face as function names
  - Three distinct highlighting styles: macros (default), regular functions (default), ldef functions (purple)
  - Makes function definitions and calls highly visible and easy to spot in code
- Added =ldefp= utility function to check if a symbol is an ldef-defined function

* 0.5.0 - 2025-11-26

** Added
- Custom exceptions in =l-exception.el=
- =lpipe= function in =l-functions=
- more type predicates and aliases
  - =:alist= =:plist= =:array= =:sequence= (=:seq=) =:bool-vector= (=:bvector=) =:char-table= (=:ctable=)
  - =:struct= =:object= =:record= =:instance= for cl-defstruct and EIEIO class instances
  - short aliases: =:buff= =:fn= =:int= =:nil= =:str=
- parameterized type matching with =:instance_of=, =:list_of=, and =:list_of_instances=
  - =:instance_of= - matches specific struct/class types: =(x :instance_of point)=
  - =:list_of= - matches lists of specific type keyword: =(nums :list_of :integer)=
  - =:list_of_instances= - matches lists of specific instance type: =(pts :list_of_instances point)=
  - new specificity scoring system: value (1M) > parameterized type (10K) > regular type (100) > wildcard (1)
- custom error types for better error handling:
  - =l-unknown-type-predicate-error= - invalid type predicates
  - =l-invalid-pattern-error= - invalid pattern syntax
  - =l-invalid-rest-parameter-error= - incorrect :rest parameter usage
  - =l-internal-error= - internal library errors
* 0.4.0 - 2025-11-23

** Added
- tests for edge cases wth l-syntax
- =lcomp= with =__= placeholder
* 0.3.3 - 2025-10-12

** Fixed
- l-syntax parse of alists

* 0.3.2 - 2025-07-31
** Added
- =auto-release.yml=  workflow and [[https://github.com/viglioni/l-el/tree/latest-release][latest-release]] branch
* 0.3.1 - 2025-07-31

** Fixed
- =straight.el= load path to library files.
* 0.3.0 - 2025-07-25

** Added
- =l-mode=
- =utilities/lcomp=
- =l-require=

** Fixed
- =with-l= behaviour with =ldef=
  
* 0.2.0 - 2025-07-15
** Added
- =:rest= parameter to =ldef=
- =lcomp= for function composition
- =l-doc= for general =ldef= documentation
** Changed
- Refactored library moving contents to =l-main.el=
- Renamed =l-partial= to =lpartial= for consistency
** Fixed
- =ldef= allowing more parameters than its definitions
- =ldef= allowing =&rest=
- =l-syntax= advices
* 0.1.0 - 2025-07-07
** Added
- Basic structure of the project
- Automatic currying with =ldef=
- Pattern matching with =ldef=
- Type matching with =ldef=
- Partial application with =l-partial=
- Placeholder substitution with =__=
- Custom syntax =with-l=
- Optional syntax transformation via =l-syntax=
