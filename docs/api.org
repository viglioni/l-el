#+title: l.el API Reference
#+options: toc:t
#+startup: show2levels

* Table of Contents
:PROPERTIES:
:TOC:      :include all :depth 2
:END:
:CONTENTS:
- [[#table-of-contents][Table of Contents]]
- [[#variables][Variables]]
  - [[#l-syntax][l-syntax]]
- [[#functions][Functions]]
  - [[#__-block-optional-arg][__ (block &optional arg)]]
  - [[#doc-docstring-rest-ldef-exprs][@doc (docstring &rest ldef-exprs)]]
  - [[#l-rest-expr][l (&rest expr)]]
  - [[#l-generic-cleanup-name][l-generic-cleanup (name)]]
  - [[#l-generic-remove-method-name-pattern-list][l-generic-remove-method (name pattern-list)]]
  - [[#l-mode][l-mode]]
  - [[#l-require-feature-optional-filename-noerror][l-require (feature &optional filename noerror)]]
  - [[#l-syntax-advices][l-syntax-advices]]
  - [[#l-syntax-remove-advices][l-syntax-remove-advices]]
  - [[#l-version][l-version]]
  - [[#ldef-name-rest-args-and-body][ldef (name &rest args-and-body)]]
  - [[#lpartial-fn-rest-init-args][lpartial (fn &rest init-args)]]
  - [[#with-l-rest-body][with-l (&rest body)]]
- [[#utilities][Utilities]]
  - [[#lcomp-rest-functions][lcomp (&rest functions)]]
- [[#type-system][Type System]]
:END:

* Variables

** =l-syntax=

Controls whether l syntax transformations are applied during evaluation.

When set to =t= globally, l syntax transformations will be applied to all elisp evaluation operations without requiring file-local variable declarations in individual files.

When set to =nil= (the default), l syntax transformations will only be applied to files that explicitly declare =l-syntax= as a file-local variable.

* Functions and macros

** =__ (block &optional arg)=

Create concise expressions with placeholder substitution, avoiding lambda boilerplate.

When called with one argument (just BLOCK), returns a function. When called with two arguments, evaluates immediately with ARG substituted for =__=.

*** Examples:
#+begin_src emacs-lisp
;; Returns a function - great for avoiding lambda boilerplate
(mapcar (__ (1+ __)) '(1 2 3))           ;; => (2 3 4)
(mapcar (__ (concat "Hello, " __)) '("Alice" "Bob"))  ;; => ("Hello, Alice" "Hello, Bob")
(seq-filter (__ (> __ 5)) '(1 8 3 9 2))  ;; => (8 9)

;; Equivalent to writing lambdas:
(mapcar (lambda (x) (1+ x)) '(1 2 3))
(mapcar (lambda (x) (concat "Hello, " x)) '("Alice" "Bob"))

;; Immediate evaluation with two arguments
(__ (1+ __) 5)           ;; => 6
(__ (upcase __) "hello") ;; => "HELLO"

;; Works with any expression
(__ (car __) '(a b c))   ;; => a
(__ (nth 2 __) '(a b c)) ;; => c

;; Multiple __ in same expression (edge case)
(__ (+ __ __) 5)         ;; => 10
(__ (list __ __) 'x)     ;; => (x x)
#+end_src

** =@doc (docstring &rest ldef-exprs)=

Add documentation to functions defined with =ldef=.

This macro provides Elixir-style documentation annotations for =ldef= functions. The docstring is associated with the function and can be retrieved later.

*** Examples:
#+begin_src emacs-lisp
@doc "Calculate the nth Fibonacci number.
This implementation uses pattern matching for base cases."
(ldef fib 0 -> 0)
(ldef fib 1 -> 1)
(ldef fib n -> (+ (fib (- n 1)) (fib (- n 2))))

@doc "Add two numbers together."
(ldef add x y -> (+ x y))
#+end_src

** =l (&rest expr)=

Lambda macro for creating functions with arrow syntax.

This macro provides a concise way to create lambda functions using arrow syntax inspired by functional programming languages. The arrow =->= separates the parameter list from the function body.

*** Syntax:
#+begin_src emacs-lisp
(l param1 param2 ... -> body-expr1 body-expr2 ...)
;; Equivalent to:
(lambda (param1 param2 ...) body-expr1 body-expr2 ...)
#+end_src

*** Examples:
#+begin_src emacs-lisp
;; Single parameter
(l x -> (* x x))
;; => (lambda (x) (* x x))

;; Multiple parameters
(l x y -> (+ x y))
;; => (lambda (x y) (+ x y))

;; Multiple body expressions
(l x y -> (message "Adding %s and %s" x y) (+ x y))
;; => (lambda (x y) (message "Adding %s and %s" x y) (+ x y))

;; Usage with funcall
(funcall (l x -> (* x 2)) 5)  ;; => 10

;; Usage with mapcar
(mapcar (l x -> (+ x 1)) '(1 2 3))  ;; => (2 3 4)

;; No parameters
(l -> 42)  ;; => (lambda () 42)
#+end_src

Note: The arrow =->= must be present in the expression.

** =l-generic-cleanup (name)=

Remove generic function NAME and all its methods.

This function completely removes a generic function from the l-generic registry and unbinds the function symbol, effectively deleting the function and all its associated method definitions.

This is useful for:
- Cleaning up during development when redefining generic functions
- Removing functions that are no longer needed
- Resolving conflicts when function names are reused

*** Examples:
#+begin_src emacs-lisp
;; Define a generic function
(ldef my-func x -> (+ x 1))

;; Remove the function completely
(l-generic-cleanup 'my-func)

;; Function is no longer available
(my-func 5)  ;; ERROR: void-function my-func
#+end_src

Note: This operation cannot be undone. All method definitions are permanently removed.

See also: =l-generic-remove-method= for removing specific implementations.

** =l-generic-remove-method (name pattern-list)=

Remove a specific method implementation from generic function NAME.

This function removes only the method that matches PATTERN-LIST from the generic function, leaving other implementations intact. The dispatch function is automatically regenerated after removal.

NAME is the symbol representing the generic function.

PATTERN-LIST is the list of patterns that identifies the specific implementation to remove. The patterns should match the original definition. Parameter names are ignored when matching - only types and values matter.

*** Return Value

Returns =t= if a method was removed, =nil= if no matching method was found.

*** Behavior

After removing the method:
- The dispatch function is regenerated with remaining methods
- If no methods remain, the function is completely removed (unbound)
- Other implementations of the same function continue to work

*** Examples:

**** Removing type-matched implementations:
#+begin_src emacs-lisp
;; Define multiple implementations
(ldef lempty (x :string) -> (string-empty-p x))
(ldef lempty (x :list) -> (null x))
(ldef lempty x -> nil)

;; Remove only the string implementation
(l-generic-remove-method 'lempty '((x :string)))

;; The other implementations still work
(lempty '())        ;; => t (list implementation)
(lempty "hello")    ;; => nil (falls back to wildcard)

;; Note: Parameter names don't matter
(l-generic-remove-method 'lempty '((lst :list)))  ;; Also removes list impl
#+end_src

**** Removing value-matched implementations:
#+begin_src emacs-lisp
;; Define fibonacci with base cases
(ldef fib 0 -> 0)
(ldef fib 1 -> 1)
(ldef fib n -> (+ (fib (- n 1)) (fib (- n 2))))

;; Remove specific value match
(l-generic-remove-method 'fib '(0))  ;; Remove fib(0) = 0

;; Now fib(0) falls back to recursive case
(fib 1)  ;; => 1 (still works)
#+end_src

**** Removing implementations with multiple parameters:
#+begin_src emacs-lisp
(ldef calc '+ x y -> (+ x y))
(ldef calc '- x y -> (- x y))
(ldef calc '* x y -> (* x y))

;; Remove addition
(l-generic-remove-method 'calc '('+ x y))

;; Other operations still work
(calc '- 10 5)  ;; => 5
(calc '* 3 4)   ;; => 12
#+end_src

**** Removing rest parameter implementations:
#+begin_src emacs-lisp
(ldef sum (nums :rest) -> (apply '+ nums))
(ldef sum x y -> (+ x y))

;; Remove rest parameter version
(l-generic-remove-method 'sum '((nums :rest)))

;; Only fixed-arity version remains
(sum 3 4)        ;; => 7
(sum 1 2 3 4)    ;; => ERROR: no matching pattern
#+end_src

*** Notes

- Parameter names are ignored when matching patterns - only types and values matter
- =(x :integer)= matches =(y :integer)= or any other parameter name with =:integer=
- Regular parameters (wildcards) all match each other: =x= matches =y=, =z=, etc.
- If the last method is removed, the function is automatically unbound
- Returns =nil= if no matching pattern is found

See also: =l-generic-cleanup= for removing all methods of a function, =ldef= for defining generic functions.

** =l-mode=

Enhanced major mode extending =emacs-lisp-mode= with specialized features for l.el.

This major mode provides:
- Enhanced syntax highlighting for =@doc= annotations and their docstrings
- Syntax highlighting for s-expressions within docstrings
- Special highlighting for escaped strings and backslashes in docstrings
- Automatic activation when =l-syntax= is enabled (via =l-syntax-advices=)
- Full Emacs Lisp compatibility

The mode treats strings following =@doc= as documentation strings (=font-lock-doc-face=) rather than regular strings.

*** Examples:
#+begin_src emacs-lisp
;; Manual activation
(l-mode)

;; Automatic activation via use-package
(use-package l
  :mode ("\\.el\\'" . l-mode))

;; Auto-enabled when l-syntax is active
(setq l-syntax t)
(l-syntax-advices)  ;; l-mode activates automatically in .el files
#+end_src

** =l-require (feature &optional filename noerror)=

Enhanced library loading with automatic l-syntax processing.

Similar to =require= but with enhanced support for files that declare l-syntax support. When loading files with l-syntax enabled, automatically processes l.el syntax transformations.

FEATURE is the feature symbol to require.
FILENAME is the optional file name to load.
NOERROR when non-nil, don't signal an error if the file is not found.

*** Examples:
#+begin_src emacs-lisp
;; Load a library with l-syntax support
(l-require 'my-l-library)

;; Load with specific filename
(l-require 'utilities "my-utils.el")

;; Load without error if not found
(l-require 'optional-feature nil t)
#+end_src

** =l-syntax-advices=

Add advice to evaluation functions for l syntax support.

This function adds around advice to =eval-last-sexp=, =eval-region=, =eval-buffer=, =load-file=, and =load= to enable l syntax processing.

** =l-syntax-remove-advices=

Remove advice from evaluation functions for l syntax support.

This function removes around advice from =eval-last-sexp=, =eval-region=, =eval-buffer=, =load-file=, and =load= that was added by =l-syntax-advices=.

** =l-version=

Return the current version of l.el.

This function returns the version string of the currently loaded l.el library. The version is automatically updated during release via the =release.el= script when running =make release-patch=, =make release-minor=, or =make release-major=.

*** Examples:
#+begin_src emacs-lisp
(l-version)  ;; => "1.0.0"
#+end_src

*** Notes

The version follows semantic versioning (MAJOR.MINOR.PATCH).

** =ldef (name &rest args-and-body)=

Define autocurried functions with pattern matching support.

Creates a function NAME that automatically curries when called with fewer arguments and supports pattern matching on arguments. Multiple definitions with the same NAME but different patterns create a generic function with multiple methods.

*** Syntax

#+begin_src emacs-lisp
(ldef name arg1 arg2 ... -> body...)
#+end_src

Arguments before =->= are parameter patterns. Body follows after =->= .

*** Parameter Patterns

Arguments support:
- Regular parameters: =arg= - matches any value, binds to =arg=
- Wildcards: =_= or =_name= - matches any value, conventionally ignored
- Direct value matches: =value= - matches when argument equals =value= (numbers, strings, keywords, quoted symbols, =nil=, =t=, vectors, lists)
- Type matches: =(arg :type)= - matches when =arg= satisfies the type predicate
- Rest parameter: =(arg :rest)= - collects remaining arguments as a list (must be last)

*Note:* Lists in patterns =(...)= always indicate type matching or rest parameters. To match literal list values, use quoted forms: ='(1 2 3)=.

*** Method Specificity

When multiple methods match, they are ordered by specificity (most specific first):
1. Value matches: 1000 points each
2. Type matches: 100 points each
3. Wildcards: 1 point each
4. Regular parameters: 0 points

The method with the highest total specificity is called first.

*** Pattern Matching Examples

**** Direct value matching:
#+begin_src emacs-lisp
;; Numbers
(ldef fib 0 -> 0)                        ;; matches when arg = 0
(ldef fib 1 -> 1)                        ;; matches when arg = 1
(ldef fib n -> (+ (fib (- n 1)) (fib (- n 2))))  ;; general case

(fib 10)  ;; => 55

;; Strings
(ldef greet "Alice" -> "Hello, Alice!")  ;; matches "Alice"
(ldef greet "Bob" -> "Hey, Bob!")        ;; matches "Bob"
(ldef greet name -> (concat "Hi, " name "!"))   ;; general case

(greet "Alice")  ;; => "Hello, Alice!"
(greet "Bob")    ;; => "Hey, Bob!"
(greet "Carol")  ;; => "Hi, Carol!"

;; Keywords
(ldef handle-status :success -> "OK")
(ldef handle-status :error -> "Failed")
(ldef handle-status status -> (format "Unknown: %s" status))

(handle-status :success)  ;; => "OK"
(handle-status :error)    ;; => "Failed"
(handle-status :warning)  ;; => "Unknown: :warning"

;; Quoted symbols
(ldef parse-sym 'nil -> "nil symbol")
(ldef parse-sym 'foo -> "foo symbol")
(ldef parse-sym x -> (format "other: %s" x))

(parse-sym 'nil)  ;; => "nil symbol"
(parse-sym 'bar)  ;; => "other: bar"

;; Booleans and nil
(ldef handle-bool nil -> "got nil")
(ldef handle-bool t -> "got true")
(ldef handle-bool x -> "got other")

(handle-bool nil)  ;; => "got nil"
(handle-bool t)    ;; => "got true"
#+end_src

**** Type matching:
#+begin_src emacs-lisp
(ldef process (x :integer) -> (* x 2))
(ldef process (x :string) -> (upcase x))
(ldef process (x :list) -> (length x))
(ldef process x -> "unknown type")

(process 5)           ;; => 10
(process "hello")     ;; => "HELLO"
(process '(1 2 3))    ;; => 3
(process :keyword)    ;; => "unknown type"
#+end_src

**** Multiple parameters with patterns:
#+begin_src emacs-lisp
;; Mix direct values with regular parameters
(ldef calc '+ x y -> (+ x y))
(ldef calc '- x y -> (- x y))
(ldef calc '* x y -> (* x y))
(ldef calc _op _x _y -> (error "Unknown operation"))

(calc '+ 10 5)  ;; => 15
(calc '- 10 5)  ;; => 5
(calc '/ 10 5)  ;; => error

;; Mix direct values with type constraints
(ldef complex-match 0 'start (x :integer) -> (format "Special: x=%d" x))
(ldef complex-match n sym (val :integer) -> (format "General: n=%s sym=%s val=%d" n sym val))
(ldef complex-match n sym val -> (format "Fallback: n=%s sym=%s val=%s" n sym val))

(complex-match 0 'start 42)   ;; => "Special: x=42"
(complex-match 5 'foo 10)     ;; => "General: n=5 sym=foo val=10"
(complex-match 5 'foo "bar")  ;; => "Fallback: n=5 sym=foo val=bar"
#+end_src

**** Complex data structure matching:
#+begin_src emacs-lisp
;; Quoted lists (alists, plists, regular lists)
(ldef handle-config '((debug . t)) -> "debug mode")
(ldef handle-config cfg -> "normal mode")

(ldef handle-opts '(:verbose t) -> "verbose")
(ldef handle-opts opts -> "quiet")

(ldef handle-list '(1 2 3) -> "specific list")
(ldef handle-list '() -> "empty list")
(ldef handle-list lst -> "other list")

;; Vectors
(ldef process-vec [] -> "empty")
(ldef process-vec [1 2 3] -> "one-two-three")
(ldef process-vec v -> "other")

;; Nested structures
(ldef handle '(:type list :items ((a . b))) -> "matched nested")
(ldef handle data -> "other data")
#+end_src

**** Wildcards:
#+begin_src emacs-lisp
(ldef ignore-first _ x -> x)
(ldef ignore-middle a _ _ d -> (list a d))

(ignore-first 1 2)        ;; => 2
(ignore-middle 1 2 3 4)   ;; => (1 4)
#+end_src

*** Rest Parameters

The =:rest= type collects all remaining arguments into a list. It must be the last parameter.

#+begin_src emacs-lisp
(ldef sum (nums :rest) -> (apply '+ nums))

(sum 1 2 3 4 5)  ;; => 15

(ldef format-with-prefix (prefix :string) (args :rest) ->
      (apply 'format (concat prefix ": %s") args))

(format-with-prefix "Error" "file not found")  ;; => "Error: file not found"
#+end_src

*** Currying

Functions defined with =ldef= automatically curry when called with fewer arguments than defined.

#+begin_src emacs-lisp
(ldef add3 x y z -> (+ x y z))

;; Full application
(add3 1 2 3)  ;; => 6

;; Partial application returns a function
(funcall (add3 1) 2 3)  ;; => 6
(funcall (add3 1 2) 3)  ;; => 6

;; Chained partial application
(funcall (funcall (add3 1) 2) 3)  ;; => 6

;; With l-syntax enabled or inside with-l:
((add3 1) 2 3)      ;; => 6
(((add3 1) 2) 3)    ;; => 6
#+end_src

*** Error Handling

When no pattern matches the provided arguments, an error is raised:

#+begin_src emacs-lisp
(ldef only-integers (x :integer) -> x)

(only-integers 5)       ;; => 5
(only-integers "hello") ;; => error: No matching method
#+end_src

*** Notes

- The =&rest= syntax from regular Emacs Lisp is NOT supported. Use =(arg :rest)= instead.
- Multiple =:rest= parameters are not allowed.
- =:rest= must be the last parameter.
- Use =l-generic-cleanup= to remove a function and all its methods.
- Use =l-generic-remove-method= to remove a specific implementation while keeping others.

** =lpartial (fn &rest init-args)=

Return a partially applied function with FN and INIT-ARGS.

Creates a new function that, when called, applies FN to the combination of INIT-ARGS (provided now) and any additional arguments (provided later).

*** Examples:
#+begin_src emacs-lisp
  (funcall (lpartial '+ 5) 3)     ;; => 8
  (funcall (lpartial '* 2 3) 4)   ;; => 24
  (funcall (lpartial 'concat "Hello, ") "World!")  ;; => "Hello, World!"
#+end_src

** =with-l (&rest body)=

Transform expressions to support curried function call syntax.

Enables the use of =((fn args) more-args)= syntax within the macro body, transforming such expressions into proper funcall forms. This allows for more natural curried function composition and chaining.

The transformation converts:
- =((fn arg1) arg2 arg3)= => =(funcall (fn arg1) arg2 arg3)=
- =(((fn arg1) arg2) arg3)= => =(funcall (funcall (fn arg1) arg2) arg3)=

Macros inside =with-l= are expanded before transformation, so macros like =lcomp= work correctly.

*** Examples:
#+begin_src emacs-lisp
(with-l ((add3 1) 2 3))     ;; => 6
(with-l (((add3 1) 2) 3))   ;; => 6
(with-l (+ ((add3 1) 2 3) ((multiply3 2) 3 4)))  ;; => 30

;; Works with lcomp and other macros
(with-l ((lcomp (+ __ 1) (* __ 2)) 5))  ;; => 11

;; Multiple expressions
(with-l
  (ldef my-add x y -> (+ x y))
  ((my-add 1) 2))  ;; => 3
#+end_src

Note: Regular function calls and special forms (=let=, =if=, =defun=, etc.) are left unchanged.

** =lcomp (&rest functions)=

Compose functions for elegant data transformation.

Returns a new function that applies FUNCTIONS in right-to-left order (mathematical composition). The rightmost function can accept multiple arguments, while subsequent functions must accept a single argument.

Each argument is automatically wrapped with =__=, so you can use the placeholder syntax directly.

*** Examples:
#+begin_src emacs-lisp
;; Basic composition with lambdas
(ldef double (l x -> (* 2 x)))
(ldef add-one (l x -> (+ 1 x)))
((lcomp add-one double) 5)  ;; => 11 (double first, then add-one)

;; Using __ placeholder syntax
((lcomp (+ __ 1) (* __ 2)) 5)  ;; => 11

;; With with-l for cleaner syntax
(with-l ((lcomp (+ __ 1) (* __ 2)) 5))  ;; => 11

;; Multiple function composition
(ldef negate (l x -> (- x)))
(ldef square (l x -> (* x x)))
((lcomp negate square add-one double) 3)  ;; => -49

;; With built-in functions
((lcomp 'car 'reverse) '(1 2 3 4))  ;; => 4

;; With local bindings
(let ((square (lambda (x) (* x x))))
  (with-l ((lcomp (+ __ 1) square) 3)))  ;; => 10
#+end_src

* Type System

The library supports the following type predicates for pattern matching:

** Primitive/specific types

- =:alist= - l--alistp (association lists =((k . v) ...)=)
- =:bool-vector= - bool-vector-p (compact bit arrays)
- =:buffer= - bufferp
- =:char-table= - char-table-p (character lookup tables)
- =:cons= - consp
- =:float= - floatp
- =:function= - functionp
- =:hash-table= - hash-table-p
- =:integer= - integerp
- =:list= - listp
- =:null= - null
- =:object= - eieio-object-p (EIEIO class instances)
- =:plist= - plistp (property lists =(:k v ...)=)
- =:record= - recordp (generic record type, includes structs and EIEIO objects)
- =:string= - stringp
- =:struct= - cl-struct-p (cl-defstruct instances)
- =:symbol= - symbolp
- =:vector= - vectorp

** Composite/category types

- =:array= - arrayp (vectors, strings, char-tables, bool-vectors)
- =:callable= - function or subroutine
- =:instance= - l--instancep (cl-defstruct and EIEIO class instances)
- =:number= - numberp (integers and floats)
- =:sequence= - sequencep (lists, vectors, strings)

** Parameterized types

These types require an additional argument to specify the exact type to match:

- Struct/class types - =(param type-name)= - matches specific struct or class type via =cl-typep= (NEW simplified syntax!)
- =:instance_of= - =(param :instance_of type-name)= - legacy syntax, still supported
- =:list_of= - =(param :list_of :type-keyword)= - matches list where every element matches a type keyword
- List of structs/classes - =(param (list type-name))= - matches list of specific type instances (NEW simplified syntax!)
- =:list_of_instances= - =(param :list_of_instances type-name)= - legacy syntax, still supported

*** Struct and Class Type Matching

**** Recommended syntax (simplified):

Usage: =(param type-name)=

This is the new, cleaner syntax for matching struct and class instances, similar to =cl-defmethod=.

Examples:
#+begin_src emacs-lisp
(cl-defstruct point x y)
(defclass person () ((name :initarg :name)))

;; Match point struct instances
(ldef process-point (p point) ->
  (format "Point at %d,%d" (point-x p) (point-y p)))

;; Match person class instances
(ldef greet-person (p person) ->
  (format "Hello %s" (oref p name)))

;; Works with built-in cl types too
(ldef double-int (n integer) -> (* n 2))
(ldef upcase-str (s string) -> (upcase s))
#+end_src

**** Legacy syntax (still supported):

Usage: =(param :instance_of type-name)=

Examples:
#+begin_src emacs-lisp
(cl-defstruct point x y)
(defclass person () ((name :initarg :name)))

(ldef process-point (p :instance_of point) ->
  ;; Only matches point structs
  (format "Point at %d,%d" (point-x p) (point-y p)))

(ldef greet-person (p :instance_of person) ->
  ;; Only matches person class instances
  (format "Hello %s" (oref p name)))
#+end_src

*** =:list_of=

Usage: =(param :list_of :type-keyword)=

Examples:
#+begin_src emacs-lisp
(ldef sum-integers (nums :list_of :integer) ->
  ;; Only matches lists where every element is an integer
  (apply #'+ nums))

(ldef join-strings (strs :list_of :string) ->
  ;; Only matches lists where every element is a string
  (mapconcat #'identity strs ", "))

(ldef process-symbols (syms :list_of :symbol) ->
  ;; Works with any type keyword from l-generic-type-predicates
  (length syms))
#+end_src

*** List of Struct/Class Instances

**** Recommended syntax (simplified):

Usage: =(param (list type-name))=

This is the new, cleaner syntax for matching lists of struct or class instances.

Examples:
#+begin_src emacs-lisp
(cl-defstruct point x y)
(defclass shape () ((name :initarg :name)))

;; Match list of point structs
(ldef process-points (pts (list point)) ->
  (mapcar (lambda (p) (+ (point-x p) (point-y p))) pts))

;; Match list of shape instances
(ldef draw-shapes (shapes (list shape)) ->
  (mapcar (lambda (s) (oref s name)) shapes))

;; Can also combine with list of keyword types
(ldef process-integers (nums (list :integer)) ->
  ;; Note: This is equivalent to (nums :list_of :integer)
  (apply #'+ nums))
#+end_src

**** Legacy syntax (still supported):

Usage: =(param :list_of_instances type-name)=

Examples:
#+begin_src emacs-lisp
(cl-defstruct point x y)
(defclass shape () ((name :initarg :name)))

(ldef process-points (pts :list_of_instances point) ->
  ;; Only matches lists where every element is a point struct
  (mapcar (lambda (p) (+ (point-x p) (point-y p))) pts))

(ldef draw-shapes (shapes :list_of_instances shape) ->
  ;; Only matches lists where every element is a shape instance
  (mapcar (lambda (s) (oref s name)) shapes))
#+end_src

*** Specificity

Parameterized types (10,000 points) are more specific than regular type predicates (100 points) but less specific than value matches (1,000,000 points).

** Aliases (short forms)

- =:buff= - alias for =:buffer=
- =:bvector= - alias for =:bool-vector=
- =:ctable= - alias for =:char-table=
- =:fn= - alias for =:function=
- =:int= - alias for =:integer=
- =:nil= - alias for =:null=
- =:seq= - alias for =:sequence=
- =:str= - alias for =:string=
